{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FuncNodes Documentation \ud83d\ude80","text":"<p>FuncNodes is a modular workflow automation system designed for data processing, AI pipelines, task automation, and more.</p> <p> (Plotly example of a FuncNodes workflow)</p>"},{"location":"#features","title":"\ud83d\udccc Features","text":"<ul> <li>Node-based Execution - Define workflows as interconnected nodes</li> <li>Asynchronous Processing - Handle tasks efficiently with async execution</li> <li>Web-Based UI - Manage workflows with a browser based No-Code interface</li> <li>Integration-Friendly - Connect to APIs, databases, and external services</li> <li>Modular &amp; Extensible - Easily create and integrate custom nodes, e.g. via decorators:</li> </ul>"},{"location":"#getting-started","title":"\ud83d\udd25 Getting Started","text":"<ul> <li>Understanding FuncNodes - Learn how FuncNodes processes workflows</li> <li>Installation Guide - Set up FuncNodes in your environment</li> <li>Using the UI - Learn how to use the FuncNodes UI</li> </ul>"},{"location":"#core-components","title":"\ud83d\udee0 Core Components","text":"<ul> <li>Nodes - The building blocks of workflows</li> <li>Inputs &amp; Outputs - Handling data flow between nodes</li> </ul>"},{"location":"#ui-deployment","title":"\ud83c\udfa8 UI &amp; Deployment","text":"<ul> <li>Using the Web-Based UI - Visualize and control workflows</li> </ul> <p>\ud83d\udca1 Need Help?</p> <ul> <li>Check the FAQ</li> <li>Report an issue on GitHub</li> <li>Join the community discussions on GitHub Discussions</li> </ul> <p>\ud83d\ude80 Happy automating with FuncNodes! \ud83c\udf89</p>"},{"location":"api/cli/","title":"FuncNodes CLI Guide","text":"<p>The FuncNodes command-line interface (CLI) allows users to manage workflows, workers, and configurations efficiently. This guide provides an overview of available commands and usage examples.</p>"},{"location":"api/cli/#getting-started","title":"Getting Started","text":"<p>To check if FuncNodes is installed and accessible, run:</p> <pre><code>funcnodes --version\n</code></pre> <p>To view all available commands:</p> <pre><code>funcnodes --help\n</code></pre>"},{"location":"api/cli/#cli-commands","title":"CLI Commands","text":""},{"location":"api/cli/#commonoptions","title":"Common Options","text":"<p>The basic command structure for the CLI is:</p> <pre><code>funcnodes [common_options] {task}\n</code></pre> <p>where {task} specifies an operation. The shared common options for all tasks are:</p> <ul> <li><code>--version</code> \u2192 Prints the current version of FuncNodes.</li> <li><code>-h, --help</code> \u2192  Displays CLI help.</li> <li><code>--dir &lt;path&gt;</code> \u2192 Specifies a custom base directory where workflow data is stored (default: <code>~/.funcnodes</code>). In this directory all configurations, logs, worker data, worker environments etc. is stored. So by defining a custom path it is possible to completly seperate instances of FuncNodes. For development purposes we recomment setting <code>--dir .funcnodes</code> (1) which will create a respective folder in your current worspace.</li> <li><code>--debug</code> \u2192  Enables debugging logs for all processes (and child processes).</li> <li><code>--profile</code> \u2192 Only available if FuncNodes was installed with the optional dependency <code>fundnodes[profiling]</code> Runs the task under profiling mode using yappi, generating a funcnodesprofile.pstat file in your current directory. This file than can be opened with different profiling views such as snakeviz</li> </ul> <ol> <li>This is also what <code>--funcnodes-module demoworker</code> does.</li> </ol>"},{"location":"api/cli/#tasks","title":"Tasks","text":"<p>The <code>funcnodes</code> command expects a specific task, which can be one of the following:</p> <ul> <li>runserver \u2192 Runs the browser interface with various options</li> <li>worker \u2192 Allows running and management of a Worker(options)</li> <li>startworkermanager \u2192 Starts the Workermanager(options)</li> <li>modules \u2192 Gives access to the installed FuncNodes modules (options)</li> </ul>"},{"location":"api/cli/#runserver","title":"runserver","text":"<p>To start the FuncNodes web UI, use:</p> <pre><code>funcnodes [common_options] runserver [server_options]\n</code></pre> <p>This will run a simple server that serves all the static static files necessary to use Funcnodes in the browser. By default the server runs on <code>localhost:8000</code> and a corresponding browser window is opened autoamtically. To interact with the Workers the server tries to find a running instance of a Workermanager under <code>localhost:9380</code> and if it cannot find a running instance it will spawn a new one. Optional argument to the command are:</p> Argument Description --host The host adress of the server, defaults to the config[\"frontend\"][\"host\"] (default:localhost) --port The port of the server, defaults to the config[\"frontend\"][\"port\"] (default:8000) --no-browser If present, does not open a browser window --no-manager The server does not automatically spawns a Workermanager --worker_manager_host  The host adress of the Workermanager the server tries to rach or under which a new one will be spawned, defaults to the config[\"worker_manager\"][\"host\"] (default:localhost) --worker_manager_port The port of the Workermanager the server tries to rach or under which a new one will be spawned, defaults to the config[\"worker_manager\"][\"port\"] (default:9380) --frontend Which frontend to use in the UI (currently only <code>react_flow</code> is supported)"},{"location":"api/cli/#worker","title":"worker","text":"<p>The task command <code>worker</code> allows to create, start, stop and interact with the Worker instances of FuncNodes. The command is build up as:</p> <pre><code>funcnodes [common_options] worker [worker_options] workertask\n</code></pre> <p>where the worker_options are mainy to define which worker to acess:</p> Argument Description --uuid The unique id of the Worker, for a new worker it will be created automatically --name The (non-unique) name of the Worker, for a new worker it defaults to the uuid but can be changed later <p>To interact with an existing Worker either <code>--uuid</code> or <code>--name</code> have to be present. If only name is given the first worker with the given name will be picked (as it is not unqiue). For new Workers a if no <code>--uuid</code> is given, it will be created automatically and if <code>--name</code> is not set, it will be the <code>uuid</code> by default.</p> <p>The command then requires a worker specific task:</p> <ul> <li>new \u2192 Creates a new Worker</li> <li>start \u2192 Runs the existing worker</li> <li>stop \u2192 Stops the existing, running worker</li> <li>modules \u2192 Runs the <code>funcnodes module</code> command in the Worker env</li> <li>list \u2192 List all existing workers</li> <li>listen \u2192 Listens to the output of an existing worker</li> <li>activate \u2192 Activates the environment of an existing worker (if present)</li> <li>py \u2192 Runs the Python instance of the respective worker</li> </ul>"},{"location":"api/cli/#worker_new","title":"new worker","text":"<p>To create a new worker via the CLI the basic command is:</p> <pre><code>funcnodes [common_options] worker [worker_options] new [new_worker_options]\n</code></pre> <p>This command creates a new worker in your current <code>&lt;funcnodes directory&gt;/worker</code> defined via the common_options (default <code>~/.funcnodes/worker</code>). If the uuid and name are not set in the worker_options they will be created automatically.</p> <p>The worker can be created with a bunch of creation options via <code>[new_worker_options]</code>:</p> Argument Description --create-only By default a newly created worker will automatically start. By setting this flag it will only be created and not started --not-in-venv By default new workers will also create their own virtual environment in there respective path. By setting this flag the worker will be initiated with the current python interpreter (and always use this interpreter even if started from another environment) (--workertype) Defines the workertype (this feature is under development and should not be used currently) <p>--not-in-venv</p> <p>The <code>--not-in-venv</code>-flag should be used carefully, since workers can automatically install packages in their environment, which is why it creates a new one by default.</p> <p>But the --not-in-venv command commes especially handy during the development of new node packages which should be tested within a worker while it is only locally available.</p> <p>This behaviour is also used by the <code>--funcnodes-module demoworker</code> command.</p>"},{"location":"api/cli/#worker_start","title":"start worker","text":"<p>To start an existing worker via the cli simlpy run</p> <pre><code>funcnodes [common_options] worker --uuid|--name start\n</code></pre> <p>This will continously run the respective worker until stopped.</p> <p>A Worker can only run one instance at a time</p> <p>The workers are running their node based programm continously. Since they have a fixed state at a given time it is not possible to run a single worker on the same machine (to be more exact with the same base folder) multiple times in paralell. As such if you try to run a worker at it is already running it will automatically stop imediatly.</p> <p>If you want to start a worker and it is not working because it says it is already running, you can either try stopping it with the stop worker command, or go into the worker directory <code>&lt;funcnodes directory&gt;/worker</code> and check for the <code>worker_&lt;uuid&gt;.p</code> file. This file contains the pid for the Worker  which can be used to kill it, or you can try to delet the file. Note: If the file is deleted, but the worker is still running, it will be recreated.</p>"},{"location":"api/cli/#worker_stop","title":"stop worker","text":"<p>To stop a running worker via the cli simlpy run</p> <pre><code>funcnodes [common_options] worker --uuid|--name stop\n</code></pre>"},{"location":"api/cli/#worker_list","title":"list all worker","text":"<p>To get a list of all workers the <code>list</code> worker task can be utilized:</p> <pre><code>funcnodes [common_options] worker list [--full]\n</code></pre> <p>e.g.</p> <pre><code>&gt;&gt; funcnodes worker list\n15e84e74d25446cdafc9339e8a437e73        myworker\n0a60b90c55e24a448b6714fce3d08aed        test\nc52079f077f94929908bbc9013941a08        dummy\n</code></pre> <p>Without the <code>--full</code> option this command will print a list of all existing workers in the form of:</p> <pre><code>&lt;uuid&gt;\\t&lt;name&gt;\n</code></pre> <p>if the <code>--full</code> option is set the output will print all configuration dictionaries of the existing Workers (see: Worker config )</p> <pre><code>&gt;&gt; funcnodes worker list --full\n[{'data_path': '~/.funcnodes/workers/worker_myworker',\n  'env_path': '~/.funcnodes/workers/worker_myworker/.venv',\n  'host': 'localhost',\n  'name': 'myworker',\n  'package_dependencies': {},\n  'pid': 39692,\n  'port': 9382,\n  'python_path': '~/.funcnodes/workers/worker_myworker/.venv/Scripts/python.exe',\n  'ssl': False,\n  'type': 'WSWorker',\n  'update_on_startup': {'funcnodes': True},\n  'uuid': 'myworker',\n  'worker_dependencies': {}},\n {'data_path': '~/.funcnodes/workers/worker_0a60b90c55e24a448b6714fce3d08aed',\n  'env_path': '~/.funcnodes/workers/worker_0a60b90c55e24a448b6714fce3d08aed/.venv',\n  'host': 'localhost',\n  'name': 'test',\n  'package_dependencies': {'funcnodes-basic': {'package': 'funcnodes-basic',\n                                               'version': '&gt;=0.2.1'},\n                           'funcnodes-files': {'package': 'funcnodes-files',\n                                               'version': '0.2.7'},\n                           'funcnodes-images': {'package': 'funcnodes-images',\n                                                'version': '0.2.2'},\n                           'funcnodes-numpy': {'package': 'funcnodes-numpy',\n                                               'version': '0.2.9'},\n                           'funcnodes-opencv': {'package': 'funcnodes-opencv',\n                                                'version': '0.2.2'},\n                           'funcnodes-storage': {'package': 'funcnodes-storage',\n                                                 'version': '0.1.0'}},\n  'pid': 31112,\n  'port': 9383,\n  'python_path': '~/.funcnodes/workers/worker_0a60b90c55e24a448b6714fce3d08aed/.venv/Scripts/python.exe',\n  'ssl': False,\n  'type': 'WSWorker',\n  'update_on_startup': {'funcnodes': True},\n  'uuid': '0a60b90c55e24a448b6714fce3d08aed',\n  'worker_dependencies': {}},\n {'data_path': '~/.funcnodes/workers/worker_15e84e74d25446cdafc9339e8a437e73',\n  'env_path': '~/.funcnodes/workers/worker_15e84e74d25446cdafc9339e8a437e73/.venv',\n  'host': 'localhost',\n  'name': 'dummy2',\n  'package_dependencies': {'funcnodes-files': {'package': 'funcnodes-files',\n                                               'version': '0.2.7'},\n                           'funcnodes-opencv': {'package': 'funcnodes-opencv',\n                                                'version': '0.2.2'}},\n  'pid': 18300,\n  'port': 9383,\n  'python_path': '~/.funcnodes/workers/worker_15e84e74d25446cdafc9339e8a437e73/.venv/Scripts/python.exe',\n  'ssl': False,\n  'type': 'WSWorker',\n  'update_on_startup': {'funcnodes': True},\n  'uuid': '15e84e74d25446cdafc9339e8a437e73',\n  'worker_dependencies': {}},\n {'data_path': '~/.funcnodes/workers/worker_c52079f077f94929908bbc9013941a08',\n  'env_path': '~/.funcnodes/workers/worker_c52079f077f94929908bbc9013941a08/.venv',\n  'host': 'localhost',\n  'name': 'dummy',\n  'package_dependencies': {'funcnodes-basic': {'package': 'funcnodes-basic',\n                                               'version': None},\n                           'funcnodes-files': {'package': 'funcnodes-files',\n                                               'version': None},\n                           'funcnodes-hplc': {'package': 'funcnodes-hplc',\n                                              'version': None},\n                           'funcnodes-opencv': {'package': 'funcnodes-opencv',\n                                                'version': '0.2.2'},\n                           'funcnodes-pandas': {'package': 'funcnodes-pandas',\n                                                'version': None},\n                           'funcnodes-plotly': {'package': 'funcnodes-plotly',\n                                                'version': None}},\n  'pid': 10568,\n  'port': 9382,\n  'python_path': '~/.funcnodes/workers/worker_c52079f077f94929908bbc9013941a08/.venv/Scripts/python.exe',\n  'ssl': False,\n  'type': 'WSWorker',\n  'update_on_startup': {'funcnodes': True},\n  'uuid': 'c52079f077f94929908bbc9013941a08',\n  'worker_dependencies': {}}]\n</code></pre>"},{"location":"api/cli/#worker_listen","title":"listen to a worker","text":"<p>The CLI provides the option to listen to a worker. It basically continously prints the log of the worker to the current output until the command is terminated. It always prints the current full log data of the worker, so it will also work with workers that are not running, in which case it will simply print the histroical logs, without any new output until the worker starts.</p> <pre><code>funcnodes [common_options] worker --uuid|--name listen\n</code></pre> <p>e.g.</p> <pre><code>&gt;&gt; funcnodes worker --name dummy listen\n2025-01-30 13:30:03,491 - funcnodes.c52079f077f94929908bbc9013941a08 - INFO - Starting worker forever\n2025-01-30 13:30:09,273 - funcnodes.c52079f077f94929908bbc9013941a08 - INFO - Setup loop manager to run\n2025-01-30 13:30:09,273 - funcnodes.c52079f077f94929908bbc9013941a08 - INFO - Starting loop manager\n2025-01-30 13:30:09,392 - funcnodes.c52079f077f94929908bbc9013941a08 - INFO - WebSocket server running on localhost:9382\n</code></pre>"},{"location":"api/cli/#worker_modules","title":"worker modules","text":"<p>This command allows to run the funcnodes module command within the worker environment</p> <p>e.g.</p> <pre><code>funcnodes [common_options] worker --uuid|--name modules list\n</code></pre>"},{"location":"api/cli/#worker_activate","title":"activate worker","text":"<p>By default each worker has its own virtual environment to make the installed modules independed for each worker.</p> <pre><code>funcnodes [common_options] worker --uuid|--name activate\n</code></pre> <p>gives a convinient way of directly entering the virtual environment (mainly for debugging purposes or if a package has to be installed manually via the terminal)</p> <p>e.g.</p> <pre><code>&gt;&gt; funcnodes worker --name dummy activate\n(worker_c52079f077f94929908bbc9013941a08)&gt;&gt;\u2588\n</code></pre>"},{"location":"api/cli/#worker_py","title":"run py in worker","text":"<pre><code>&gt;&gt; funcnodes  worker --uuid|--name py [python_args]\n</code></pre> <p>This worker task is short for</p> <pre><code>&gt;&gt; funcnodes  worker --uuid|--name activate\n(env)&gt;&gt; python [python_args]\n</code></pre> <p>and can be used to directly execute python scripts or task with the python interpreter of the worker</p> <p>e.g.</p> <pre><code>&gt;&gt; funcnodes worker --name dummy py -- -c \"print(\\\"hello\\\")\" # (1)!\nhello\n&gt;&gt; funcnodes worker --name dummy py -- --version\n</code></pre> <ol> <li>If arguments have to be passed to the python directly command they must be seperated via -- from the main command and string quotations need to be properly escaped.</li> </ol> <p>or: with a local srypt <code>myscript.py</code></p> <pre><code># myscript.py\nimport sys\nprint(sys.argv)\n</code></pre> <pre><code>&gt;&gt; funcnodes worker --name dummy py myscript.py  --innerarg\n['myscript.py', '--innerarg']\n</code></pre>"},{"location":"api/cli/#workermanager","title":"workermanager","text":"<p>To start a Workermanager via the cli you can run</p> <pre><code>funcnodes [common_options] startworkermanager [workermanager_options]\n</code></pre> <p>The optional arguments for this command are:</p> Argument Description --host The host of the Workermanager, defaults to the config[\"worker_manager\"][\"host\"] (default:localhost) --port The port of the Workermanager, defaults to the config[\"worker_manager\"][\"port\"] (default:9380)"},{"location":"api/cli/#modules","title":"modules","text":"<p>Funcnodes has a way of automatically detecting available Nodes in the current environment.</p> <p>The nodes have to be packed in a common NodeModule.</p> <p>To list all Modules in the current environment run:</p> <pre><code>funcnodes [common_options] modules list\n</code></pre> <p>the output will be an indent list of the installed funcnodes modules: in the form of:</p> <pre><code>funcnodes_basic:\n        InstalledModule(name=funcnodes_basic, description=Basic functionalities for\n                funcnodes, entry_points=['module', 'shelf'], version=0.2.1, react_plugin=False,\n                render_options=False)\n</code></pre>"},{"location":"components/config/","title":"Funcnodes Config","text":"<p>NOT IMPLEMENTED NOT IMPLEMENTED.</p>"},{"location":"components/inputs-outputs/","title":"Inputs &amp; Outputs","text":"<p>In FuncNodes, inputs and outputs (IOs) serve as the fundamental connection points between nodes. They are responsible for handling the flow of data and triggering execution throughout a workflow. Both inputs and outputs extend from a common foundation\u2014the NodeIO Base Class\u2014which provides shared functionality for connection management, value handling, serialization, and event emission.</p> <p>The main principle is that each IO can hold an arbitrary data object, referenceable via the <code>value</code> property. If the value is not set it is automatically set to the NoValue singleton object which is used to represent the absence of a value. This is important because None is a valid value for an IO.</p> <p>If the value of an IO is changed this may trigger a range of events, including e.g. triggering the Node or passing its value to connected IOs.</p>"},{"location":"components/inputs-outputs/#nodeio-base-class","title":"NodeIO Base Class","text":"<p>The inputs and outputs of a Node are both derived from the <code>NodeIO</code> base class. This class accepts the following parameters (for nromal use cases NodeIO is never intialized directly, but always via the child classes):</p> <ul> <li>uuid: Each IO has a unique ID that is generated when the IO is created. (1)</li> <li>name: Each IO has a name that is used as the referencing key and also for display purposes (defaults to the uuid).</li> <li>description: A description of the IO, mainly used for display purposes.</li> <li>type: The data type of the IO. This is treated as a hint for the UI and the backend, but is not enforced.</li> <li>allow_multiple: A boolean flag that indicates whether the IO have multiple connections to other IOs. By default this is False for inputs and True for outputs.</li> <li>hidden: A boolean flag that indicates whether the IO is hidden in the UI. This is useful for internal IOs or for very IO-rich nodes, to make them more usable.</li> <li>render_options: See Render Options.</li> <li>value_options: See Value Options.</li> </ul> <ol> <li>Note: if the IO is derived of a function parameter, the id becomes the signature name of the parameter, so it is not individually unique. But IOs are always attasched to a node, with a unique id, so the combination of node id and IO id is always unique.</li> </ol>"},{"location":"components/inputs-outputs/#render-options","title":"Render Options","text":"<p>The IO-Render options are used to control and customize the appearance of the IO in the UI. In its base form these options are available:</p> <ul> <li>type: If the IO Type is different than what is should be rendered at (e.g. a number that should be rendered as a string or a custom frontend component, this can be set here).</li> <li>set_default: If the value of the IO is set manually, this flag indicates whether the new value should be set as the default value for the IO (meaning it will also be serialized, and has to be serializable).</li> </ul> <p>The render options are a dictionary, meaning it can be arbitrary extended with custom options. Which will be passed to the frontend and can there be used to customize the rendering of the IO.</p>"},{"location":"components/inputs-outputs/#value-options","title":"Value Options","text":"<p>The IO-Value options are used to control and customize the behavior of the IO-value. Currently these values are not directly enforced, but are used as hints for the UI and the backend and if required should be enforced in the respective node functions:</p> <ul> <li>min: The minimum value of the IO, currently used for number types.</li> <li>max: The maximum value of the IO, currently used for number types (1).</li> <li>step: The step size of the IO, currently used for number types.</li> <li>options: A list of options that the IO can take, rendered as a dropdown (2).</li> </ul> <ol> <li>Note: If min and max are set the default frontend renders the IO as a slider.</li> <li>For more control this can also be defined as a enum type in the form of a dictionary with keys and values (see example below).</li> </ol> <pre><code>import funcnodes as fn\n\nclass IOModNode(fn.Node):\n    node_id = \"iomodnode\"\n    a = fn.NodeInput(\n        value_options={\"min\": 0, \"max\": 1, \"step\": 0.1}, default=0.5, type=float\n    )\n\n    b = fn.NodeInput(\n        render_options={\"type\": \"color\"}, type=str, default=\"#ff0000\"\n    )\n\n    c = fn.NodeInput(\n        value_options={\"options\": [\"a\", \"b\", \"c\"]}, default=\"a\", type=str\n    )\n    d = fn.NodeInput(\n        value_options={\n            \"options\": {\n                \"type\": \"enum\",\n                \"keys\": [\"full\", \"empty\"],\n                \"values\": [1, 0],\n            }\n        }\n    )\n\n    async def func(self, a: float, b: str, c: str, d: float):\n        self.inputs[\"a\"].set_value(float(d), does_trigger=False)\n</code></pre>"},{"location":"components/lib/","title":"Libraries","text":"<p>NOT IMPLEMENTED NOT IMPLEMENTED.</p>"},{"location":"components/node/","title":"Nodes","text":"<p>Nodes are the most fundamental building blocks of FuncNodes. Each node encapsulates a function with defined inputs and outputs. Nodes execute when all required inputs are available, producing output data for downstream nodes. Nodes can be created with two different methods: class based and decorator based. While class based nodes are more flexible and can be used to create complex nodes, decorator based nodes are simpler and faster to create.</p>"},{"location":"components/node/#class-based-nodes","title":"Class Based Nodes","text":"<p>Class based nodes are created by subclassing the <code>Node</code> class from the <code>funcnodes</code> package. This method is more flexible and allows for more complex nodes to be created. The <code>Node</code> class provides a number of methods and properties that can be overridden to customize the behavior of the node.</p> <p>The basic layout of a class based node is as follows:</p> <pre><code>import funcnodes as fn\n\nclass MyNode(fn.Node):\n    node_name = \"My Node\"\n    node_id = \"my_node\"\n\n    async def func(self):\n        \"\"\"The function to be executed when the node is triggered.\"\"\"\n</code></pre> <p>The <code>node_name</code> and <code>node_id</code> required properties define the name and ID of the node, respectively. It is important that the 'node_id' is unique across all nodes in the system since it is used for serialization and deserialization of the node. So it is recommended to make it as descriptive as possible, e.g. if the node CalculateOrbit is part of a public package named 'funcnodes_astronomy' and the node the node_id could be 'funcnodes_astronomy.calculate_orbit'. And while this is not enforced it is recommended to use a similar naming scheme for the ids, to prevent id clashes. The node name is the human readable name of the node and is used in the UI.</p> <p>The async <code>func</code> method is the entry point for the node's execution. This method is called when the node is triggered and should contain the logic for the node's function.In the class based nodes the <code>func</code> method is the only method that is required to be implemented. The <code>func</code> method has to be an async method since the execution of the node is done asynchronously.</p> <p>The node above has no inputs or outputs, which makes it relatively useless. inputs and outputs can be added on the class level as well:</p> <pre><code>import funcnodes as fn\n\nclass MyNode(fn.Node):\n    node_name = \"My Node\"\n    node_id = \"my_node\"\n\n    input1 = fn.NodeInput(id=\"input1\", type=int)\n    input2 = fn.NodeInput(id=\"input2\", type=int)\n\n    output1 = fn.NodeOutput(id=\"output1\", type=int)\n\n\n    async def func(self, input1, input2):\n\n        result =  input1 + input2\n        self.outputs[\"output1\"].value = result\n</code></pre> <p>In the example above, the node has two inputs, <code>input1</code> and <code>input2</code>, and one output, <code>output</code>. The <code>func</code> method now takes two arguments, <code>input1</code> and <code>input2</code>, which are the values of the inputs. The <code>func</code> method then adds the two inputs together and sets the result as the value of the output. While the class attributes of the inputs and outputs can be arbitrary named, it is recommended to use the same name as the id of the input or output (IO), to make the code more readable. setting the type of the IO is optional, but it is recommended since this will be used to render the corresponding IO in the UI (defaults to Any).</p> <p>Warning</p> <p>The typing of the IO is not enforced, to stay as pythonic as possible. If the value is not of the expected type, the node will still trigger and raise an exception if it occurs.</p> <p>This is important to keep the system flexible: e.g. numpy arrays can be passed to inputs that expect a list and it should still work.</p> <p>If enforcing is required, it should be done in the <code>func</code> method.</p> <p>During triggering all inputs are passed to the <code>func</code> method as keyword arguments, so the order of the inputs does not matter, but the ids should be valid python variable names. In the class based approach outputs have to be set explicitly, by setting the value of the output in the <code>func</code> method. For more details on the <code>IO</code> see the Inputs and Outputs.</p>"},{"location":"components/node/#decorator-based-nodes","title":"Decorator Based Nodes","text":"<p>A even simpler way to create nodes is by using the <code>@fn.NodeDecorator</code> decorator. This decorator can be used to create nodes from a simple function. The function should take the inputs as arguments and return the outputs as a dictionary. The decorator will automatically create the node and set the inputs and outputs based on the function signature.</p> <pre><code>import funcnodes as fn\n\n@fn.NodeDecorator(node_id=\"my_node\")\ndef my_node(input1: int, input2: int) -&gt; float:\n    return input1 / input2\n</code></pre> <p>This will create a node with the id <code>my_node</code>, which has two inputs, <code>input1</code> and <code>input2</code> (of type <code>int</code>), and one output, <code>output1</code> (of type <code>float</code>).</p> <p>The <code>@fn.NodeDecorator</code> decorator has the required argument <code>node_id</code>, which is the id of the node, similar to the <code>node_id</code> property in the class based nodes. The inputs are automatically created based on the function signature, as such the function should have only defined positional and keyword arguments and no expanding arguments like <code>*args</code> or <code>**kwargs</code>. Similar to the class based nodes, the type of the inputs is optional, but recommended.</p> <p>The Decorator can also be used to create a Node from an arbitrary external function, by passing the function as an argument to the decorator. The corresponding inputs and outputs will be created based on the signature of the function and the type hints.</p> <pre><code>import funcnodes as fn\n\ndef myfunction(a: int=1, b: int=2) -&gt; int:\n    return a + b\n\nMyFuncNode = fn.NodeDecorator(\n    node_id=\"my_node\",\n)(myfunction)\n</code></pre> <p>The outputs are defined by the return type of the function, the output type is also interpreted from the return type, if present. The default id if the output is <code>out</code> and the default type is <code>Any</code>.</p> <p>How the Node input and Output can be further customized with decorators is described in the Inputs and Outputs section.</p>"},{"location":"components/node/#defining-multiple-outputs","title":"Defining multiple outputs","text":"<p>Will the class based approach allows for multiple outputs simply by defining multiple outputs, the decorator requires a little modification.</p> <p>To have multiple outputs, the function should return multiple values, which would make the return type a tuple.</p> <pre><code>import funcnodes as fn\n\n@fn.NodeDecorator(node_id=\"my_node\")\ndef my_node(input1: int, input2: int) -&gt; tuple:\n    result1 =  input1 + input2\n    result2 =  input1 - input2\n    return result1, result2\n</code></pre> <p>But this will result in a single output <code>out</code> of the type tuple. To actually have multiple outputs the return type has to be a typed tuple, to be able to interfere the number of outputs:</p> <pre><code>from typing import Tuple\nimport funcnodes as fn\n\n@fn.NodeDecorator(\n    node_id=\"my_node\",\n)\ndef my_node(input1: int, input2: int) -&gt; Tuple[int, int]:\n    result1 =  input1 + input2\n    result2 =  input1 - input2\n    return result1, result2\n</code></pre> <p>By default the outputs are numbered, to give them a more descriptive name, the outputs can be customized with the <code>outputs</code> argument of the decorator:</p> <pre><code>from typing import Tuple\nimport funcnodes as fn\n\n@fn.NodeDecorator(\n    node_id=\"my_node\",\n    outputs=[\n        {\"name\": \"output1\"},\n        {\"name\": \"output2\"},\n    ]\n)\ndef my_node(input1: int, input2: int) -&gt; Tuple[int, int]:\n    result1 =  input1 + input2\n    result2 =  input1 - input2\n    return result1, result2\n</code></pre> <p>The <code>outputs</code> argument of the decorator is a list of dictionaries, where each dictionary represents an output. The dictionary should have the key <code>name</code> which is the id of the output. To specify the type, the <code>type</code> argument can be used. Alternatively, the type can be specified in the return type of the function as in the example above.</p>"},{"location":"components/node/#further-info-in-io-in-decorator","title":"Further info in IO in decorator","text":"<p>In a similar manner the inputs can be customized with the <code>inputs</code> argument.</p> <pre><code>from typing import Tuple\nimport funcnodes as fn\n\n@fn.NodeDecorator(\n    node_id=\"my_node\",\n    inputs=[\n        {\"name\": \"a\"},\n        {\"name\": \"b\"},\n    ],\n)\ndef myfunction(var_name_i_dont_like_a: int=1, var_name_i_dont_like_b: int=2) -&gt; int:\n    return var_name_i_dont_like_a + var_name_i_dont_like_b\n</code></pre> <p>Defining the inputs and outputs in the decorator is especially useful when the function is an external function and the signature cannot be changed.</p> <p>In the following example, the function <code>divmod</code> is an external function and the signature cannot be changed.</p> <pre><code>from typing import Tuple\nimport funcnodes as fn\n\nMyFuncNode = fn.NodeDecorator(\n    node_id=\"divmod\",\n)(divmod)\n</code></pre> <p>As you can see the function has the expected inputs, but it is not typed. As such the inputs are of type <code>Any</code>, which allows no manual input and the return type is not defined, meaning the function has no output.</p> <p>To fix this, the inputs and outputs can be defined in the decorator.</p> <pre><code>from typing import Tuple\nimport funcnodes as fn\n\n\nMyFuncNode = fn.NodeDecorator(\n    node_id=\"divmod\",\n    inputs=[\n        {\"name\": \"a\"},\n        {\"name\": \"b\"},\n    ],\n    outputs=[\n        {\"name\": \"quotient\", \"type\": int},\n        {\"name\": \"remainder\", \"type\": int},\n    ]\n)(divmod)\n</code></pre> <p>While under normal circumstances this works as expected, it is recommended to use the <code>fn.NodeDecorator</code> as a decorator, and create a wrapper function that calls the external function, to make the node more readable and to allow for more customization.</p> <pre><code>from typing import Tuple\nimport funcnodes as fn\n\n\n@fn.NodeDecorator(\n    node_id=\"divmod\",\n    outputs=[\n        {\"name\": \"quotient\"},\n        {\"name\": \"remainder\"},\n    ]\n)\ndef divmod_node(a: int=11, b: int=5) -&gt; Tuple[int, int]:\n    return divmod(a, b)\n</code></pre> <p>Furthermore by wrapping it in a function, it can be make sure, that the function accepts all arguments as keyword arguments. Since internally Funcnodes calls the function with all-keyword arguments, which is some functions don't accept:</p> <pre><code>from typing import Tuple\nimport funcnodes as fn\n\nMyFuncNode = fn.NodeDecorator(\n    node_id=\"divmod\",\n    inputs=[\n        {\"name\": \"a\", \"default\":11}, # setting default to show the effect\n        {\"name\": \"b\", \"default\":5},\n    ],\n    outputs=[\n        {\"name\": \"quotient\", \"type\": int},\n        {\"name\": \"remainder\", \"type\": int},\n    ]\n)(divmod) # this will not work since divmod does not accept keyword arguments\n</code></pre>"},{"location":"components/node/#defining-the-node-name","title":"Defining the node name","text":"<p>The node name is especially important for the UI, as it is the human readable name of the node. If not present, the node name will be the name of the function or the class. To set the node name, the <code>node_name</code> class attribute or the <code>name</code> argument of the decorator can be used.</p> <pre><code>import funcnodes as fn\n\n@fn.NodeDecorator(node_id=\"my_node1\", name=\"My Node Decorator\")\ndef my_node(input1: int, input2: int) -&gt; float:\n    return input1 / input2\n\nclass MyNode(fn.Node):\n    node_name = \"My Node Class\"\n    node_id = \"my_node2\"\n\n    async def func(self):\n        pass\n</code></pre>"},{"location":"components/node/#defining-the-node-description","title":"Defining the node description","text":"<p>In a similar manner the node description can be set with the <code>description</code> argument of the decorator or the <code>description</code> class attribute of the class based nodes.</p> <p>Description is a human readable description of the node, which can be used to provide more information about the node to the user.</p> <p>Additionaly if no description is provided, the docstring of the function or the class will be used as the description (if present).</p> <pre><code>import funcnodes as fn\n\n@fn.NodeDecorator(node_id=\"my_node1\", description=\"This is a node created with the decorator\")\ndef my_node(ip:int) -&gt; float:\n    return ip/2\n\n@fn.NodeDecorator(node_id=\"my_node2\")\ndef my_node(ip:int) -&gt; float:\n    \"\"\"This is a node created with the decorator and a docstring\"\"\"\n    return ip/2\n\nclass MyNode(fn.Node):\n    node_name = \"My Node Class\"\n    node_id = \"my_node3\"\n    description = \"\"\"\nThis is a node created with the class\n\nMulti line is supported\n    \"\"\"\n\n    ip = fn.NodeInput(id=\"ip\", type=int)\n\n    async def func(self, ip):\n        self.outputs[\"output1\"].value = ip / 2\n</code></pre> <p>(Hover over the node header in the UI to see the description)</p> <p>Future Plans</p> <p>We plan to render the description as via Markdown/Sphinx in the UI, so it is recommended to use Markdown in the description.</p>"},{"location":"components/node/#node-progress-bar","title":"Node progress bar","text":"<p>Especially for long running nodes, it is recommended to provide a progress bar to the user. For this purpose the node has a custom property <code>progress</code> which wraps the <code>tqdm</code> progress bar and automatically streams the progress to the UI.</p> <pre><code>import asyncio\nimport funcnodes as fn\n\nclass MyNode(fn.Node):\n    node_name = \"My Node Class\"\n    node_id = \"my_node3\"\n    description = \"This is a node created with the class\"\n\n    ip = fn.NodeInput(id=\"ip\", type=int,default=30)\n\n    async def func(self, ip):\n        for i in self.progress(range(ip)):\n            await asyncio.sleep(10)\n</code></pre> <p>(All nodes on this page here run in parallel processes in pyodide, each with all the individual management overhead, which is why the progress bar is not 100% iterating with the sleep time. A normal use-case would be only little processes with multiple nodes per process)</p> <p>To access the progress bar in a decorator based node, we need to access the underlying node object. For this purpose an input argument <code>node</code> can be added, which will not be considered as normal input, but as a reference to the node object.</p> <pre><code>import asyncio\nimport funcnodes as fn\n\n@fn.NodeDecorator(node_id=\"my_node\")\nasync def my_node(ip:int=30, node: fn.Node=None) -&gt; float:\n    for i in node.progress(range(ip)):\n        await asyncio.sleep(10)\n\n    return ip/2\n</code></pre>"},{"location":"components/node/#heavy-tasks","title":"Heavy Tasks","text":"<p>Since Funcnodes uses the asyncio library, a blocking function will block the event loop and prevent other nodes from executing. To prevent this, heavy tasks should be executed in a separate thread or process. This can be done e.g. by using the <code>asyncio.to_thread</code> function, which will run the function in a separate thread and return the result.</p> <pre><code>import asyncio\nimport time\nimport funcnodes as fn\n\n@fn.NodeDecorator(node_id=\"my_node\")\nasync def my_node(input1: int, input2: int) -&gt; int:\n    def heavy_task(input1, input2):\n        time.sleep(1)\n        return input1 + input2\n\n    return await asyncio.to_thread(heavy_task, input1, input2)\n</code></pre> <p>Pyodide Runtime</p> <p>Funcnodes is also able to run in pyodide (\"Pyodide makes it possible to install and run Python packages in the browser\"). We use this also in all the Nodes you see here running live. But pyodide does not yet support multithreading or multiprocessing.</p> <p>This works for both class based and decorator based nodes. Alternatively, the NodeDecorator accepts a <code>separate_thread=True</code> argument, which will automatically run the function in a separate thread. (The decorator alternativly accepts a <code>separate_process=True</code> argument, which will run the function in a separate process, but this is still experimental and should only considered for heavy CPU bound tasks)</p>"},{"location":"components/node/#nested-inheritance","title":"Nested Inheritance","text":"<p>While the class based approach allows for more complex inheritance patterns:</p> <pre><code>import funcnodes as fn\n\nclass BaseNode(fn.Node):\n    \"\"\"\n    `Abstract` base class does not need a `func` method or a `node_id`\n    \"\"\"\n\n    my_id = fn.NodeOutput(id=\"my_id\", type=int)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.outputs[\"my_id\"].value = id(self)\n\n\nclass MyNode(BaseNode):\n    node_name = \"My Node\"\n    node_id = \"my_node\"\n\n    input1 = fn.NodeInput(id=\"input1\", type=int)\n    input2 = fn.NodeInput(id=\"input2\", type=int)\n\n    output1 = fn.NodeOutput(id=\"output1\", type=int)\n\n    async def func(self, input1, input2):\n        result =  input1 + input2\n        self.outputs[\"output1\"].value = result\n\nclass MyNodeTwo(BaseNode):\n    node_name = \"My Node Two\"\n    node_id = \"my_node_two\"\n\n    input1 = fn.NodeInput(id=\"input1\", type=int)\n    output1 = fn.NodeOutput(id=\"output1\", type=float)\n\n    async def func(self, input1):\n        self.outputs[\"output1\"].value = input1/2\n</code></pre> <p>The decorator also allows to use different baseclasses than the default <code>Node</code> class, by using the <code>superclass</code> argument of the decorator.</p> <pre><code>import funcnodes as fn\n\nclass BaseNode(fn.Node):\n    \"\"\"\n    `Abstract` base class does not need a `func` method or a `node_id`\n    \"\"\"\n\n    my_id = fn.NodeOutput(id=\"my_id\", type=int)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.outputs[\"my_id\"].value = id(self)\n\n\n@fn.NodeDecorator(node_id=\"my_node\", superclass=BaseNode)\ndef my_node(input1: int, input2: int) -&gt; int:\n    return input1 + input2\n\ninstance = my_node()\ninstance.outputs[\"my_id\"].value == id(instance) # True\n</code></pre>"},{"location":"components/node/#try-it-out-yourself","title":"Try it out yourself","text":""},{"location":"components/nodeinput/","title":"Node Inputs","text":"<p>NOT IMPLEMENTED NOT IMPLEMENTED.</p>"},{"location":"components/nodeoutput/","title":"Node Outputs","text":"<p>NOT IMPLEMENTED NOT IMPLEMENTED.</p>"},{"location":"components/nodespace/","title":"Nodespace","text":"<p>NOT IMPLEMENTED NOT IMPLEMENTED.</p>"},{"location":"components/serialization/","title":"Serialization","text":"<p>NOT IMPLEMENTED NOT IMPLEMENTED.</p>"},{"location":"components/shelf/","title":"Shelfes","text":"<p>NOT IMPLEMENTED NOT IMPLEMENTED.</p>"},{"location":"components/worker_config/","title":"Worker Config","text":"<p>NOT IMPLEMENTED NOT IMPLEMENTED.</p>"},{"location":"examples/","title":"Overview","text":"<p>Pyodide examples</p> <p>This page contains examples of using Funcnodes within Pyodide. Since all runs in your browser and python has to be compiled to WebAssembly on each page load, the examples might take a few seconds to load and the execution might be slower than on a native python installation.</p>"},{"location":"examples/#reading-csv","title":"Reading csv","text":"<p>This example a simle csv data is read and analyzed. The result are exported to an excel file. </p>"},{"location":"examples/#image-analysis","title":"Image Analysis","text":"<p>This example shows that Funcnodes workes with OpenCV and you can perform live image analysis in the browser. </p>"},{"location":"examples/#plotly","title":"Plotly","text":"<p>This example shows how to use Plotly to create interactive plots in the browser using Funcnodes. </p>"},{"location":"faq/common-issues/","title":"Common Issues","text":"<p>Not yet created</p>"},{"location":"getting-started/basic_usage/","title":"Use FuncNodes","text":""},{"location":"getting-started/basic_usage/#start-the-ui","title":"Start the UI","text":"<p>The core use case of FuncNodes is to bring arbitrary complex functionalities into a node-based no-code interface.</p> <p>To start the UI simply call:</p> <pre><code>funcnodes runserver # (1)!\n</code></pre> <ol> <li>For more options see the CLI options</li> </ol> <p>This will spawn a browser window with the basic FuncNodes Interface: </p>"},{"location":"getting-started/basic_usage/#first-worker","title":"First Worker","text":""},{"location":"getting-started/basic_usage/#create-worker","title":"Create Worker","text":"<p>Workers are basically individuall programms that live within the FuncNodes framework. They are usually running completely seperated from each other and contain the necessary modules and the current state of the complete workflow.</p> <p>To create a new worker simply click on the <code>Worker</code> menu \u2192 <code>New</code>, enter a name and click <code>Create</code>. This will create a new Worker with the given name in the Worker directory (default <code>~/.funcnodes/worker</code>) and also set up the virtual environment for the Worker. </p>"},{"location":"getting-started/basic_usage/#run-worker","title":"Run Worker","text":"<p>To start the newly created Worker click on the worker name under <code>Worker</code> \u2192 <code>select</code>. You can see that the worker is active if the <code>Nodespace</code> header menu and the <code>Manage Libraries</code></p> <p></p>"},{"location":"getting-started/basic_usage/#add-functionalities","title":"Add Functionalities","text":"<p>FuncNodes provides its functionalities in the form of Nodes. These nodes are shipped as normal python packages with a specific layout and entry points for auto detection.</p> <p>The UI currently grabs a list of available modules from our managed repository list and shows them under <code>Manage Libraries</code></p> <p>If you click on <code>Manage Libraries</code> a window opens that shows you a List of:</p> <ul> <li>Installed modules, that are not used by the worker</li> <li>Installable modules</li> <li>Modules that are currently used by the Worker</li> </ul> <p>New modules can simply added via the <code>Add</code> button</p> <p></p> <p>If a new module is added its Shelf becomes available in the <code>Lib</code> menu</p>"},{"location":"getting-started/basic_usage/#adding-and-working-with-nodes","title":"Adding and working with Nodes","text":"<p>Nodes are the core components of FuncNodes and are the simples computing unit in the framework and are basically functions with Inputs and Outputs. Inputs can be either connected to other node's outputs or set manually (if the underlying datatype allows it).</p> <p>Nodes can be added from the Library by selecting the specific shelf (and sub-shelf) or searched via the search bar in the lib. By double-clicking the name of the Node a new Instance is added to the Nodespace in the center.</p> <p></p> <p>Ones a Node is created its inputs can be set and the outputs can be connected to the inputs of other Nodes. Ones the input of a Node changes it is triggered and the created outputs are passed to connected inputs.</p> <p>If you hover over inputs and outputs its current value is shown, allowing for live feedback.</p> <p>To highlight what you can really do with FuncNodes plase head to the Examples</p>"},{"location":"getting-started/installation/","title":"Getting started","text":"<p>FuncNodes is a powerful workflow automation system designed for modular and scalable execution. If you're familiar with Python, you can install FuncNodes with <code>pip</code>, the Python package manager. We also aim an stand alone Docker installation and local executables, but they are not yet finished.</p>"},{"location":"getting-started/installation/#with-pip","title":"With pip recommended","text":"<p>FuncNodes is published as a Python package and can be installed with <code>pip</code>, ideally using a virtual environment. Open a terminal and install FuncNodes with:</p> LatestVersion 0.5 <pre><code>pip install funcnodes\n</code></pre> <pre><code>pip install funcnodes==\"0.5\"\n</code></pre> <p>This will automatically install all required dependencies, including <code>funcnodes-core</code>, <code>funcnodes-basic</code>, and other essential packages. FuncNodes always strives to support the latest versions, so there's no need to install dependencies separately.</p>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>To confirm that FuncNodes is installed correctly, run:</p> <pre><code>funcnodes --version\n</code></pre> <p>This should display the installed version of FuncNodes. If you encounter any issues, check the troubleshooting guide.</p>"},{"location":"getting-started/introduction/","title":"Understanding the Working Principles of FuncNodes","text":"<p>FuncNodes is a modular workflow automation framework designed to handle complex tasks using node-based execution. It enables users to construct workflows by interconnecting nodes, where each node represents an individual computational function. This guide provides a high-level overview of how FuncNodes operates internally.</p>"},{"location":"getting-started/introduction/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/introduction/#nodes","title":"Nodes","text":"<ul> <li>The fundamental building blocks of FuncNodes.</li> <li>Each node encapsulates a function with defined inputs and outputs.</li> <li>Nodes execute when all required inputs are available, producing output data for downstream nodes.</li> <li>Nodes are extremly easy to create, simply but a decorator to a existing function and the corresponding Node is created with the correct inputs and outputs automatically.</li> </ul>"},{"location":"getting-started/introduction/#node-connections-data-flow","title":"Node Connections &amp; Data Flow","text":"<ul> <li>Nodes are connected via inputs and outputs, forming a directed acyclic graph (DAG).</li> <li>Data flows from one node\u2019s output to another\u2019s input, triggering execution dynamically.</li> </ul>"},{"location":"getting-started/introduction/#workers-execution-environments","title":"Workers &amp; Execution Environments","text":"<ul> <li>Nodes execute inside Workers, which are isolated execution units.</li> <li>Workers ensure that processes are sandboxed, preventing conflicts between workflows.</li> <li>Each worker can run on its own virtual environment, ensuring dependency isolation.</li> </ul>"},{"location":"getting-started/introduction/#workermanager","title":"Workermanager","text":"<ul> <li>The Workermanager orchestrates multiple workers.</li> <li>Manages worker lifecycle, logging, and monitoring.</li> </ul>"},{"location":"getting-started/introduction/#event-driven-execution","title":"Event-Driven Execution","text":"<ul> <li>FuncNodes follows an event-driven model, where each input change triggers execution.</li> <li>Execution order is determined dynamically based on data dependencies.</li> <li>Nodes can be triggered synchronously or asynchronously depending on their function.</li> </ul>"},{"location":"getting-started/introduction/#execution-lifecycle","title":"Execution Lifecycle","text":""},{"location":"getting-started/introduction/#workflow-initialization","title":"Workflow Initialization","text":"<ul> <li>Users define a workflow by arranging nodes and connecting them.</li> <li>The workflow is loaded into a Worker, ready for execution.</li> </ul>"},{"location":"getting-started/introduction/#input-handling-triggering","title":"Input Handling &amp; Triggering","text":"<ul> <li>When an input value changes, the connected node is triggered.</li> <li>If all required inputs are available, the node executes its function.</li> </ul>"},{"location":"getting-started/introduction/#processing-data-flow","title":"Processing &amp; Data Flow","text":"<ul> <li>The node processes its input, generating output values.</li> <li>These outputs are passed to the connected nodes, potentially triggering their execution.</li> </ul>"},{"location":"getting-started/introduction/#asynchronous-parallel-execution","title":"Asynchronous &amp; Parallel Execution","text":"<ul> <li>Multiple nodes can execute in parallel if they don\u2019t have data dependencies.</li> <li>Workers manage parallelism and ensure optimized execution.</li> </ul>"},{"location":"getting-started/introduction/#logging-debugging","title":"Logging &amp; Debugging","text":"<ul> <li>Execution logs are collected in real-time, allowing users to debug workflows.</li> <li>Users can monitor execution status and the underlying data through the FuncNodes Web UI.</li> </ul>"},{"location":"getting-started/introduction/#key-features-that-enable-efficient-processing","title":"Key Features that Enable Efficient Processing","text":"<ul> <li>Modular Architecture \u2013 Nodes can be customized and extended via plugins.</li> <li>Web-Based UI \u2013 Graphical workflow editor for easy management.</li> <li>Event-Driven Execution \u2013 Nodes trigger dynamically based on data changes.</li> <li>Python &amp; API Integration \u2013 Supports Python-based functions and external API calls.</li> </ul>"},{"location":"getting-started/introduction/#example-use-case-image-processing-pipeline","title":"Example Use Case: Image Processing Pipeline","text":"<p>The live data preview of FuncNodes comes of course especially handy when working with visual data like images. In this example, we demonstrate how FuncNodes can be used to create an image processing pipeline. Each node performs a specific operation on the input image, color space conversion, blurring area detection, filtering and finally the output. Basically we create a grey-scale image of the image except, in this case where the cat has red fur.</p> <p>You can see that every node shown a live preview of the current state of the image Inputs can be dynamically changed and are rendered depending on the underlying data type (e.g. numeric inputs are rendered as sliders when defined with a minimum and maximum).</p>"},{"location":"getting-started/introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Learn more about Nodes and their Configuration.</li> <li>Explore How Inputs and Outputs Work.</li> <li>Set up your first workflow with Basic Usage Guide.</li> </ul>"},{"location":"ui-guide/react_flow/web-ui/","title":"Using the Web-Based UI","text":"<p>FuncNodes provides a web-based UI for managing and visualizing workflows in an interactive and intuitive manner. This guide walks you through setting up and using the UI effectively.</p>"},{"location":"ui-guide/react_flow/web-ui/#starting-the-web-ui","title":"Starting the Web UI","text":"<p>To start the web UI, ensure you have FuncNodes installed and then run:</p> <pre><code>funcnodes runserver\n</code></pre> <p>This will start the FuncNodes server, and you can access the UI by navigating to:</p> <pre><code>http://localhost:8000\n</code></pre>"},{"location":"ui-guide/react_flow/web-ui/#ui-features","title":"UI Features","text":""},{"location":"ui-guide/react_flow/web-ui/#1-workflow-editor","title":"1\ufe0f\u20e3 Workflow Editor","text":"<ul> <li>Drag-and-drop interface for creating workflows.</li> <li>Connect nodes visually to define execution flow.</li> <li>Edit node properties directly in the UI.</li> </ul>"},{"location":"ui-guide/react_flow/web-ui/#2-node-configuration","title":"2\ufe0f\u20e3 Node Configuration","text":"<ul> <li>Click on a node to modify its parameters.</li> <li>Supports custom inputs and outputs.</li> <li>Dynamic validation and live updates.</li> </ul>"},{"location":"ui-guide/react_flow/web-ui/#3-execution-monitoring","title":"3\ufe0f\u20e3 Execution Monitoring","text":"<ul> <li>Start, stop, and debug workflows.</li> <li>Real-time status updates for node execution.</li> <li>View logs and error messages directly in the UI.</li> </ul>"},{"location":"ui-guide/react_flow/web-ui/#4-saving-loading-workflows","title":"4\ufe0f\u20e3 Saving &amp; Loading Workflows","text":"<ul> <li>Save workflows as JSON configurations.</li> <li>Load previously saved workflows.</li> <li>Export workflows for sharing or deployment.</li> </ul>"},{"location":"ui-guide/react_flow/web-ui/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"ui-guide/react_flow/web-ui/#customizing-the-ui-port","title":"Customizing the UI Port","text":"<p>By default, the UI runs on port <code>8000</code>. To change this:</p> <pre><code>funcnodes runserver --port 8080\n</code></pre>"},{"location":"ui-guide/react_flow/web-ui/#securing-the-web-ui","title":"Securing the Web UI","text":"<p>To enable authentication or SSL, modify the FuncNodes configuration file at:</p> <pre><code>~/.funcnodes/config.json\n</code></pre> <p>Add:</p> <pre><code>{\n  \"frontend\": {\n    \"host\": \"0.0.0.0\",\n    \"port\": 8000,\n    \"ssl\": true\n  }\n}\n</code></pre>"},{"location":"ui-guide/react_flow/web-ui/#what-you-might-need-to-add","title":"What You Might Need to Add","text":"<ul> <li>User Authentication: If access control is required, add login functionality.</li> <li>API Integration: Document how to interact with the UI programmatically.</li> <li>Custom Themes: Explain how to modify the UI styling.</li> <li>Performance Optimization: Guide on handling large workflows efficiently.</li> <li>Deployment Guide: Steps to host the UI on a remote server.</li> </ul> <p>For more details, visit the FuncNodes GitHub repository.</p>"}]}