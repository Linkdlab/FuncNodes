from __future__ import annotations

from dataclasses import dataclass
import os
from pathlib import Path
import plistlib
import shutil
import subprocess
import sys
from typing import Literal, Optional


FNW_EXT = ".fnw"
FNW_MIME = "application/x-funcnodes-fnw"
FNW_PROG_ID = "FuncNodes.WorkerFile"
FNW_DESCRIPTION = "FuncNodes Worker File"


def render_launcher_windows(python_exe: str) -> str:
    return "\n".join(
        [
            "@echo off",
            "setlocal",
            "",
            "REM Auto-generated by: funcnodes standalone --register",
            "REM Standalone launcher for .fnw files",
            "",
            'set "PY=' + python_exe + '"',
            'set "ARGS=standalone"',
            "",
            'if "%~1"=="" (',
            "    echo Usage: %~nx0 ^<file.fnw^>",
            "    exit /b 1",
            ")",
            "",
            'set "FNW_FILE=%~1"',
            "",
            '"%PY%" -m funcnodes %ARGS% "%FNW_FILE%"',
            "endlocal",
            "",
        ]
    )


def render_launcher_unix(python_exe: str, *, shell: str = "/usr/bin/env bash") -> str:
    return "\n".join(
        [
            f"#!{shell}",
            "",
            "# Auto-generated by: funcnodes standalone --register",
            "",
            f'PY="{python_exe}"',
            'ARGS="standalone"',
            "",
            'if [ "${1:-}" = "" ]; then',
            '  echo "Usage: $(basename "$0") <file.fnw>" >&2',
            "  exit 1",
            "fi",
            "",
            'FNW_FILE="$1"',
            '"$PY" -m funcnodes $ARGS "$FNW_FILE"',
            "",
        ]
    )


def read_package_icon_bytes(fmt: Literal["ico", "png", "icns"]) -> bytes:
    from importlib.resources import files

    icon = files("funcnodes.files").joinpath(f"icon.{fmt}")
    return icon.read_bytes()


def copy_package_icon(
    fmt: Literal["ico", "png", "icns"], dest: Path, *, force: bool = False
) -> Path:
    if dest.exists() and not force:
        return dest
    dest.parent.mkdir(parents=True, exist_ok=True)
    dest.write_bytes(read_package_icon_bytes(fmt))
    return dest


def write_launcher_script(*, platform: str, scripts_dir: Path, python_exe: str) -> Path:
    scripts_dir.mkdir(parents=True, exist_ok=True)

    if platform.startswith("win"):
        path = scripts_dir / "fnw_open.cmd"
        path.write_text(render_launcher_windows(python_exe), encoding="utf-8")
        return path

    path = scripts_dir / "fnw_open.sh"
    path.write_text(render_launcher_unix(python_exe), encoding="utf-8")
    path.chmod(path.stat().st_mode | 0o111)
    return path


def build_linux_mime_xml() -> str:
    return "\n".join(
        [
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<mime-info xmlns="http://www.freedesktop.org/standards/shared-mime-info">',
            f'  <mime-type type="{FNW_MIME}">',
            f"    <comment>{FNW_DESCRIPTION}</comment>",
            f'    <glob pattern="*{FNW_EXT}"/>',
            "  </mime-type>",
            "</mime-info>",
            "",
        ]
    )


def build_linux_desktop_entry(*, exec_path: Path, icon_path: Path) -> str:
    return "\n".join(
        [
            "[Desktop Entry]",
            "Version=1.0",
            "Type=Application",
            f"Name={FNW_DESCRIPTION}",
            "Comment=Open FuncNodes .fnw files",
            f'Exec="{exec_path}" %f',
            f"Icon={icon_path}",
            f"MimeType={FNW_MIME};",
            "Terminal=false",
            "Categories=Development;",
            "",
        ]
    )


def build_windows_registry_entries(
    *, launcher_path: Path, icon_path: Path
) -> dict[str, str]:
    return {
        "ext": FNW_EXT,
        "prog_id": FNW_PROG_ID,
        "description": FNW_DESCRIPTION,
        "open_command": f'"{launcher_path}" "%1"',
        "default_icon": f'"{icon_path}",0',
    }


def register_fnw(*, config_dir: Optional[Path] = None) -> None:
    import funcnodes_core as fn_core

    resolved_config_dir = (
        Path(config_dir).expanduser().resolve()
        if config_dir is not None
        else Path(fn_core.config.get_config_dir()).expanduser().resolve()
    )
    scripts_dir = resolved_config_dir / "scripts"
    python_exe = str(Path(sys.executable).expanduser().resolve())
    platform = sys.platform

    launcher = write_launcher_script(
        platform=platform, scripts_dir=scripts_dir, python_exe=python_exe
    )

    if platform.startswith("win"):
        icon = copy_package_icon("ico", scripts_dir / "fnw_icon.ico", force=True)
        _register_windows(launcher_path=launcher, icon_path=icon)
        return

    if platform == "darwin":
        icon = read_package_icon_bytes("icns")
        _register_macos(
            config_dir=resolved_config_dir, python_exe=python_exe, icon_icns=icon
        )
        return

    icon_png = copy_package_icon("png", scripts_dir / "fnw_icon.png", force=True)
    _register_linux(
        scripts_dir=scripts_dir,
        launcher_path=launcher,
        icon_png_path=icon_png,
    )


def _register_windows(*, launcher_path: Path, icon_path: Path) -> None:
    import winreg

    entries = build_windows_registry_entries(
        launcher_path=launcher_path, icon_path=icon_path
    )

    ext = entries["ext"]
    prog_id = entries["prog_id"]
    description = entries["description"]
    open_command = entries["open_command"]
    default_icon = entries["default_icon"]

    with winreg.CreateKey(winreg.HKEY_CURRENT_USER, rf"Software\Classes\{ext}") as key:
        winreg.SetValueEx(key, "", 0, winreg.REG_SZ, prog_id)

    with winreg.CreateKey(
        winreg.HKEY_CURRENT_USER, rf"Software\Classes\{prog_id}"
    ) as key:
        winreg.SetValueEx(key, "", 0, winreg.REG_SZ, description)

    with winreg.CreateKey(
        winreg.HKEY_CURRENT_USER, rf"Software\Classes\{prog_id}\DefaultIcon"
    ) as key:
        winreg.SetValueEx(key, "", 0, winreg.REG_SZ, default_icon)

    with winreg.CreateKey(
        winreg.HKEY_CURRENT_USER, rf"Software\Classes\{prog_id}\shell\open\command"
    ) as key:
        winreg.SetValueEx(key, "", 0, winreg.REG_SZ, open_command)


def _linux_data_home() -> Path:
    value = os.environ.get("XDG_DATA_HOME")
    if value:
        return Path(value).expanduser().resolve()
    return (Path.home() / ".local" / "share").expanduser().resolve()


def _register_linux(
    *, scripts_dir: Path, launcher_path: Path, icon_png_path: Path
) -> None:
    data_home = _linux_data_home()
    mime_dir = data_home / "mime" / "packages"
    applications_dir = data_home / "applications"
    mime_icon_dir = data_home / "icons" / "hicolor" / "64x64" / "mimetypes"

    mime_dir.mkdir(parents=True, exist_ok=True)
    applications_dir.mkdir(parents=True, exist_ok=True)
    mime_icon_dir.mkdir(parents=True, exist_ok=True)

    (mime_dir / "funcnodes-fnw.xml").write_text(
        build_linux_mime_xml(), encoding="utf-8"
    )
    (applications_dir / "funcnodes-fnw.desktop").write_text(
        build_linux_desktop_entry(exec_path=launcher_path, icon_path=icon_png_path),
        encoding="utf-8",
    )

    mime_icon_name = FNW_MIME.replace("/", "-") + ".png"
    shutil.copy2(icon_png_path, mime_icon_dir / mime_icon_name)

    _run_if_available(["update-mime-database", str(data_home / "mime")])
    _run_if_available(["update-desktop-database", str(applications_dir)])
    _run_if_available(["xdg-mime", "default", "funcnodes-fnw.desktop", FNW_MIME])
    _run_if_available(
        ["gtk-update-icon-cache", "-f", "-t", str(data_home / "icons" / "hicolor")]
    )


def _run_if_available(cmd: list[str]) -> None:
    if shutil.which(cmd[0]) is None:
        return
    subprocess.run(cmd, check=False)


@dataclass(frozen=True)
class _MacAppPaths:
    app_dir: Path
    resources_dir: Path
    info_plist: Path
    icon_path: Path


def _mac_app_paths(config_dir: Path) -> _MacAppPaths:
    app_dir = config_dir / "FuncNodesFNW.app"
    contents = app_dir / "Contents"
    resources_dir = contents / "Resources"
    return _MacAppPaths(
        app_dir=app_dir,
        resources_dir=resources_dir,
        info_plist=contents / "Info.plist",
        icon_path=resources_dir / "fnw_icon.icns",
    )


def _register_macos(*, config_dir: Path, python_exe: str, icon_icns: bytes) -> None:
    paths = _mac_app_paths(config_dir)
    paths.resources_dir.mkdir(parents=True, exist_ok=True)

    applescript = _build_macos_applescript(python_exe=python_exe)
    script_path = (config_dir / "FuncNodesFNW.applescript").resolve()
    script_path.write_text(applescript, encoding="utf-8")

    if shutil.which("osacompile") is not None:
        subprocess.run(
            ["osacompile", "-o", str(paths.app_dir), str(script_path)], check=False
        )

    # Best-effort icon + Info.plist patching (works for both osacompile output and custom bundles).
    paths.icon_path.write_bytes(icon_icns)

    info = {}
    if paths.info_plist.exists():
        try:
            info = plistlib.loads(paths.info_plist.read_bytes()) or {}
        except Exception:
            info = {}

    info.update(
        {
            "CFBundleIdentifier": "com.funcnodes.fnw-opener",
            "CFBundleName": "FuncNodes",
            "CFBundleDisplayName": "FuncNodes",
            "CFBundleIconFile": "fnw_icon",
            "CFBundleDocumentTypes": [
                {
                    "CFBundleTypeName": FNW_DESCRIPTION,
                    "CFBundleTypeRole": "Viewer",
                    "CFBundleTypeExtensions": ["fnw"],
                    "CFBundleTypeIconFile": "fnw_icon",
                }
            ],
        }
    )
    paths.info_plist.parent.mkdir(parents=True, exist_ok=True)
    paths.info_plist.write_bytes(plistlib.dumps(info))

    lsregister = _find_lsregister()
    if lsregister is not None:
        subprocess.run([str(lsregister), "-f", str(paths.app_dir)], check=False)

    # Setting the *default* handler programmatically is brittle; best-effort only.
    if shutil.which("duti") is not None:
        subprocess.run(
            ["duti", "-s", "com.funcnodes.fnw-opener", "fnw", "all"], check=False
        )


def _build_macos_applescript(*, python_exe: str) -> str:
    return "\n".join(
        [
            "-- Auto-generated by: funcnodes standalone --register",
            "on open theFiles",
            f'    set py to "{python_exe}"',
            "    repeat with f in theFiles",
            "        set p to POSIX path of f",
            '        do shell script (quoted form of py) & " -m funcnodes standalone " & (quoted form of p) & " &"',
            "    end repeat",
            "end open",
            "",
        ]
    )


def _find_lsregister() -> Optional[Path]:
    candidates = [
        Path(
            "/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister"
        ),
        Path("/System/Library/Frameworks/CoreServices.framework/Support/lsregister"),
    ]
    for candidate in candidates:
        if candidate.exists():
            return candidate
    return None
